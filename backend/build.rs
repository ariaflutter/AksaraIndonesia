// backend/build.rs

use std::env;
use std::fs;
use std::path::Path;
use std::collections::BTreeMap;
use postgres::{Client, NoTls};
use heck::ToUpperCamelCase;

fn main() {
    println!("cargo:rerun-if-changed=migrations/");
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:warning=--- Build script started ---");

    if dotenvy::from_filename(".env").is_err() {
        println!("cargo:warning=Could not find .env file in backend directory.");
    }
    
    let db_url = match env::var("DATABASE_URL") {
        Ok(url) => {
            println!("cargo:warning=Found DATABASE_URL.");
            url
        },
        Err(_) => { 
            println!("cargo:warning=DATABASE_URL not found, skipping code generation."); 
            return; 
        }
    };
    
    println!("cargo:warning=Attempting to connect to database...");
    let mut client = match Client::connect(&db_url, NoTls) {
        Ok(client) => {
            println!("cargo:warning=Database connection successful!");
            client
        },
        Err(e) => { 
            panic!("Could not connect to the database to generate types. Is the Docker container running? Error: {}", e);
        }
    };

    // Use the correct relative path. This is the most portable and desired solution.
    let ts_export_path_str = "../../frontend/src/lib/types/backend.d.ts";
    let ts_collector_attribute = format!("#[ts(export_to = \"{}\")]", ts_export_path_str);
    println!("cargo:warning=TypeScript export path set to: {}", ts_export_path_str);

    // Ensure the parent directory exists so the file can be created.
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let ts_export_path = Path::new(&manifest_dir).join(ts_export_path_str);
    if let Some(parent_dir) = ts_export_path.parent() {
        fs::create_dir_all(parent_dir)
            .expect("Could not create parent directories for TS export path.");
    }

    // --- Prepare strings for code generation ---
    let mut enums_code = String::new();
    enums_code.push_str("//! This file is auto-generated by build.rs. DO NOT EDIT.\n");
    enums_code.push_str("//! Contains database ENUM type definitions.\n\n");
    enums_code.push_str("use serde::{Deserialize, Serialize};\n");
    enums_code.push_str("use ts_rs::TS;\n\n");

    let mut models_code = String::new();
    models_code.push_str("//! This file is auto-generated by build.rs. DO NOT EDIT.\n");
    models_code.push_str("//! Contains database table models.\n\n");
    models_code.push_str("use serde::{Deserialize, Serialize};\n");
    models_code.push_str("use ts_rs::TS;\n");
    models_code.push_str("use chrono::{NaiveDate, DateTime, Utc};\n");
    models_code.push_str("use super::types::*;\n\n");

    // --- Generate the individual types ---
    generate_enums(&mut client, &mut enums_code);

    let tables_to_generate = ["kanwil", "bapas", "users", "klien"];
    for table_name in tables_to_generate {
        generate_struct_for_table(&mut client, table_name, &mut models_code);
    }
    
    // --- Append the "collector" type to each file's content ---
    enums_code.push_str(&format!("#[derive(TS)]\n{}\npub enum AllEnumTypes {{}}\n", ts_collector_attribute));
    models_code.push_str(&format!("#[derive(TS)]\n{}\npub enum AllModelTypes {{}}\n", ts_collector_attribute));

    // --- Write both files ---
    let types_path = Path::new(&manifest_dir).join("src").join("types.rs");
    fs::write(&types_path, enums_code).expect("Failed to write generated types (enums) file.");

    let models_path = Path::new(&manifest_dir).join("src").join("generated_models.rs");
    fs::write(&models_path, models_code).expect("Failed to write generated models file.");

    println!("cargo:warning=Generated models and types files have been updated.");
}

// MODIFIED: This function now only adds `#[ts(export)]` to each type
fn generate_enums(client: &mut Client, rust_code: &mut String) {
    let rows = client.query(
        r#" SELECT t.typname AS enum_name, e.enumlabel AS enum_value
            FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid  
            JOIN pg_namespace n ON n.oid = t.typnamespace
            WHERE n.nspname = 'public' AND t.typtype = 'e'
            ORDER BY enum_name, e.enumsortorder "#, &[]).unwrap();

    let mut enums: BTreeMap<String, Vec<String>> = BTreeMap::new();
    for row in rows {
        enums.entry(row.get("enum_name")).or_default().push(row.get("enum_value"));
    }

    for (db_name, values) in enums {
        let rust_name = db_name.to_upper_camel_case();
        rust_code.push_str("#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, sqlx::Type, TS)]\n");
        rust_code.push_str(&format!("#[sqlx(type_name = \"{}\")]\n", db_name));
        rust_code.push_str("#[ts(export)]\n"); // <-- THE CHANGE IS HERE
        rust_code.push_str(&format!("pub enum {} {{\n", rust_name));
        for value in values {
            let rust_variant = value.to_upper_camel_case();
            if rust_variant != value {
                rust_code.push_str(&format!("    #[sqlx(rename = \"{}\")] #[serde(rename = \"{}\")]\n", value, value));
            }
            rust_code.push_str(&format!("    {},\n", rust_variant));
        }
        rust_code.push_str("}\n\n");
    }
}

// MODIFIED: This function now only adds `#[ts(export)]` to each type
fn generate_struct_for_table(client: &mut Client, table_name: &str, rust_code: &mut String) {
    let rows = client.query(
        r#" SELECT column_name, udt_name, is_nullable
            FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = $1
            ORDER BY ordinal_position "#, &[&table_name]).unwrap();

    let struct_name = table_name.to_upper_camel_case();
    rust_code.push_str("#[derive(Debug, Serialize, sqlx::FromRow, TS)]\n");
    rust_code.push_str("#[ts(export)]\n"); // <-- THE CHANGE IS HERE
    rust_code.push_str(&format!("pub struct {} {{\n", struct_name));
    
    for row in rows {
        let col_name: String = row.get("column_name");
        let col_type: String = row.get("udt_name");
        let is_nullable: String = row.get("is_nullable");

        let mut rust_type = match col_type.as_str() {
            "int4" | "serial" => "i32".to_string(),
            "varchar" | "text" => "String".to_string(),
            "bool" => "bool".to_string(),
            "date" => "NaiveDate".to_string(),
            "timestamptz" => "DateTime<Utc>".to_string(),
            ty if ty.starts_with('_') => format!("Vec<{}>", ty[1..].to_string().to_upper_camel_case()),
            ty => ty.to_upper_camel_case(),
        };

        if is_nullable == "YES" {
            rust_type = format!("Option<{}>", rust_type);
        }
        
        if col_name == "password_hash" {
            rust_code.push_str("    #[serde(skip_serializing)]\n");
        }
        
        rust_code.push_str(&format!("    pub {}: {},\n", col_name, rust_type));
    }
    rust_code.push_str("}\n\n");
}